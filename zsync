#!/bin/bash
# v0.7

# TODO: fall back from bookmarks to snapshot (get last snapshot form destination and search for it on source)
# TODO: handle errors if refresh fails (wrong dest dataset for incremental send) (echo $? returns not 0)
## ex error: cannot receive incremental stream: most recent snapshot of edrive2/test does not match incremental source
## use an older snapshot of edrive2/test if it exists
## or (use -f to overwrite anyway)
# TODO: add ssh support
# TODO: add ssh source support
# TODO: add resume support

BOOKMARK_SUFFIX="zsync_incremental"
DATETIME=$(date +"%Y_%m_%d__%H_%M_%S")

USAGE=$(cat <<-END
Usage: zsync [OPTION] <source dataset> <destination dataset>
 or    zsync -s, -ssh <source dataset> [<USER>@]<HOST>:<destination dataset>
END
)

HELP="
Uses ZFS send/recieve to sync a ZFS filesystem between source and destination\n
$USAGE\n
Options
 -s, --ssh      send stream to a destination over ssh
"


log(){
	printf "$1\n"
}

init() {
    zfs snapshot $snap_name
    
    if [ "$ssh" = true ]; then
        log "Sending '$snap_name' to '$destination' on remote '$dest_host'"
        zfs send $snap_name | pv | ssh $dest_host zfs recv -vu $destination
    else
        log "Sending '$snap_name' to '$destination'"
        zfs send $snap_name | pv | zfs recv -vu $destination
    fi

    # if the send command completely sucessfully
    if [ $? -eq 0 ]; then
        # convert the source snapshot to a bookmark for future incremental sends
        zfs bookmark $snap_name $bookmark_name
    fi

    zfs destroy $snap_name
}


refresh() {
    zfs snapshot $snap_name

    if [ "$ssh" = true ]; then
        log "Sending incremental snapshot '$snap_name' to '$destination' on remote '$dest_host'"
        zfs send -i $bookmark_name $snap_name | pv | ssh $dest_host zfs recv -vFu $destination
    else
        log "Sending incremental snapshot '$snap_name' to '$destination'"
        zfs send -i $bookmark_name $snap_name | pv | zfs recv -vFu $destination
    fi

    # if the send command completely sucessfully
    if [ $? -eq 0 ]; then
        # convert the source snapshot to a bookmark for future incremental sends (overwrite previous bookmark)
        zfs destroy $bookmark_name
        zfs bookmark $snap_name $bookmark_name

        # only save most recent snapshot on destination
        zfs list -t snapshot $destination | tail -n +2 | awk '{print $1}' | head -n -1 | xargs -I snap zfs destroy snap
    else
        log "Error: ZFS send failed."
    fi

    # delete the snapshot that was used for the source
    zfs destroy $snap_name
}




# Check that required programs exist on machine
if ! command -v zfs &> /dev/null; then
    log "Error: zfs: command not found."
    exit
fi

if ! command -v pv &> /dev/null; then
    log "Error: pv: command not found."
    exit
fi


ssh=false

while test $# -gt 0; do
    case "$1" in
        -h|--help)
            log "$HELP"
            exit
            ;;
        -s|--ssh)
            ssh=true
            shift
            ;;
        *)
            break
            ;;
    esac
done


# Check for required arguments
if (( $# < 1 )); then
    log "Error: missing source argument."
    log "$USAGE"
    exit
elif (( $# < 2 )); then
    log "Error: missing destination argument."
    log "$USAGE"
    exit
fi

source=$1
destination=$2

if [ "$ssh" = true ]; then
    dest_host="${destination%:*}"
    destination="${destination#*:}"
fi

dest_pool="${destination%/*}"

log $dest_pool

# check that source dataset exists
if (( $(zfs list | grep $source | wc -l ) == 0 )); then
    log "Error: source dataset \"$source\" does not exist"
    exit
fi

# check that destination pool exists
if (( $(zpool list | grep $dest_pool | wc -l ) == 0 )); then
    log "Error: destination pool \"$dest_pool\" does not exist"
    if grep -q ":" <<< $dest_pool; then
        log "Did you mean to specify ssh (-s)?"
    fi
    exit
fi


snap_name="$source@backup_$DATETIME"
bookmark_name="$source#$dest_pool-$BOOKMARK_SUFFIX"

# if last bookmark and destination dataset exist
if (( $(zfs list -t bookmark $source | grep $bookmark_name | wc -l) > 0 )) && (( $(zfs list -r $dest_pool -o name | grep $destination | wc -l) > 0 )); then
    refresh
else
    init
fi
