#!/bin/bash
# v0.9.1b1

# TODO - URGENT: support non wildcard destinations
# TODO: check for more destinations after syncing to the first drive

# TODO: fall back from bookmarks to snapshot (get last snapshot form destination and search for it on source)
# TODO: handle errors if refresh fails (wrong dest dataset for incremental send) (echo $? returns not 0)
## ex error: cannot receive incremental stream: most recent snapshot of edrive2/test does not match incremental source
## use an older snapshot of edrive2/test if it exists
## or (use -f to overwrite anyway)
# TODO: add ssh source support (if zfs supports it)
# TODO: add resume support

BOOKMARK_SUFFIX="zsync_incremental"
DATETIME=$(date +"%Y_%m_%d__%H_%M_%S")

USAGE=$(cat <<-END
Usage: zsync [OPTION] <source dataset> <destination dataset>
 or    zsync <-s | -ssh> <source dataset> [<USER>@]<HOST>:<destination dataset>
END
)

HELP="
Uses ZFS send/recieve to sync a ZFS filesystem between source and destination\n
$USAGE\n
Options
 -s, --ssh      Send stream to a destination over ssh
 -h, --help     Show help
 -v,            Enable verbose output. Only error messages will be sent unless this is specified
"

ssh=false
verbose=false


log(){
        printf "$1\n"
}

init() {
    zfs snapshot $snap_name

    if [ "$ssh" = true ]; then
        log "Sending '$snap_name' to '$destination' on remote '$dest_host'"

        if [ "$verbose" = true ]; then
            zfs send -w $snap_name | pv | ssh $dest_host zfs recv -vu $destination
        else
            zfs send -w $snap_name | ssh $dest_host zfs recv -vu $destination
        fi
    else
        log "Sending '$snap_name' to '$destination'"

        if [ "$verbose" = true ]; then
            zfs send -w $snap_name | pv | zfs recv -vu $destination
        else
            zfs send -w $snap_name | zfs recv -vu $destination
        fi
    fi

    # if the send command completely sucessfully
    if [ $? -eq 0 ]; then
        # if bookmark already exists, delete it
        if (( $(zfs list -t bookmark $source | grep $bookmark_name | wc -l) > 0 )); then
            zfs destroy $bookmark_name
        fi

        # convert the source snapshot to a bookmark for future incremental sends
        zfs bookmark $snap_name $bookmark_name

        # if snapshot => bookmark conversion succeeded
        if [ $? -eq 0 ]; then
            zfs destroy $snap_name
        fi
    else
        zfs destroy $snap_name
    fi
}


refresh() {
    zfs snapshot $snap_name

    if [ "$ssh" = true ]; then
        log "Sending incremental snapshot '$snap_name' to '$destination' on remote '$dest_host'"

        if [ "$verbose" = true ]; then
            zfs send -wi $bookmark_name $snap_name | pv | ssh $dest_host zfs recv -vFu $destination
        else
            zfs send -wi $bookmark_name $snap_name | ssh $dest_host zfs recv -vFu $destination
        fi
    else
        log "Sending incremental snapshot '$snap_name' to '$destination'"

        if [ "$verbose" = true ]; then
            zfs send -wi $bookmark_name $snap_name | pv | zfs recv -vFu $destination
        else
            zfs send -wi $bookmark_name $snap_name | zfs recv -vFu $destination
        fi
    fi

    # if the send command completely sucessfully
    if [ $? -eq 0 ]; then
        # convert the source snapshot to a bookmark for future incremental sends (overwrite previous bookmark)
        zfs destroy $bookmark_name
        zfs bookmark $snap_name $bookmark_name

        # only save most recent snapshot on destination
        zfs list -t snapshot $destination | tail -n +2 | awk '{print $1}' | head -n -1 | xargs -I snap zfs destroy snap
    else
        log "Error: ZFS send failed."
    fi

    # delete the snapshot that was used for the source
    zfs destroy $snap_name
}


check_dest() {
    destination=$1

    if [ "$verbose" = true ]; then echo "Checking destination: ${destination}"; fi

    if [ "$ssh" = true ]; then
        dest_host="${destination%:*}"
        destination="${destination#*:}"
    fi

    dest_pool="${destination%%/*}"

    # check that destination pool exists
    if (( $(zpool list | grep $dest_pool | wc -l ) == 0 )); then
        log "zpool '$dest_pool' not found. Attempting to import"
        zpool import $dest_pool

        if (( $(zpool list | grep $dest_pool | wc -l ) == 0 )); then
            log "Error: destination pool \"$dest_pool\" does not exist"
            if grep -q ":" <<< $dest_pool; then
                log "Did you mean to specify ssh (-s)?"
            fi
            false; return
        else
            if [ "$verbose" = true ]; then echo "Destination: ${destination} found."; fi
            true; return
        fi
    fi

}



while test $# -gt 0; do
    case "$1" in
        -h|--help)
            log "$HELP"
            exit
            ;;
        -v)
            verbose=true
            shift
            ;;
        -s|--ssh)
            ssh=true
            shift
            ;;
        *)
            break
            ;;
    esac
done

# Check that required programs exist on machine
if ! command -v zfs &> /dev/null; then
    log "Error: zfs: command not found."
    exit
fi

if [ "$verbose" = true ] && ! command -v pv &> /dev/null; then
    log "Error: pv: command not found."
    exit
fi


# Check for required arguments
if (( $# < 1 )); then
    log "Error: missing source argument."
    log "$USAGE"
    exit
elif (( $# < 2 )); then
    log "Error: missing destination argument."
    log "$USAGE"
    exit
fi


# Check for wildcard
WILDCARD="*"
arg2=$2
if [ "$ssh" = false ]; then
    if [[ "$arg2" == *"$WILDCARD"* ]]; then
        if [ "$verbose" = true ]; then echo "Checking Wildcards"; fi

        for SUB in 1 2 3 4 5
        do
            DEST="${arg2/"$WILDCARD"/"$SUB"}"

            if check_dest $DEST
            then
                dest_pool="${DEST%%/*}"
                break
            fi
        done
    else
        if [ "$verbose" = true ]; then echo "Checking destination"; fi
        if check_dest $arg2
        then
            dest_pool="${arg2%%/*}"
        fi
    fi
else
    dest_host="${arg2%:*}"
    destination="${arg2#*:}"
    dest_pool="${destination%%/*}"

    echo "FUCK YOU"
    echo $dest_host
    echo $destination
    echo $dest_pool
fi



source=$1

# check that source dataset exists
if (( $(zfs list | grep $source | wc -l ) == 0 )); then
    log "Error: source dataset \"$source\" does not exist"
    exit
fi



snap_name="$source@backup_$DATETIME"
bookmark_name="$source#$dest_pool-$BOOKMARK_SUFFIX"

# if last bookmark and destination dataset exist
if (( $(zfs list -t bookmark $source | grep $bookmark_name | wc -l) > 0 )) && (( $(zfs list -r $dest_pool -o name | grep $destination | wc -l) > 0 )); then
    refresh
else
    # add verbose output - reason for init
    # do something if bookmark doesnt exist but destination dataset does
    init
fi

# export pool so the media can be removed
zpool export $dest_pool

#TODO: send export over ssh
